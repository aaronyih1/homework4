{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww12600\viewh7800\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qr

\f0\fs24 \cf0 Aaron Yih\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 a.) The most notable obstacle I overcame was trying to call the moveToEnd method with a string array. For some reason, the compiler would not recognize the function even thought the name was correct. I think there was a conflict in the fact that the parameter was a const string [] while the parameter that I was passing was just a plain string []. What I did to solve this problem was figure out a different way to approach the problem without calling this function.\
\
b.)Test cases:\
\
	1.) int enumerate(const string a[], int n, string target);\
		i.) negative n value()\
		ii.) all values equal target()\
		iii.) no values are equal to target()\
		iv.) valid test case()\
		v.) n is shorter than array length()\
		vi.) n is larger than array length()\
	2.) int locate(const string a[], int n, string target);\
		i.) negative n value()\
		ii.) no value equal to target()\
		iii.) case matters for comparison()\
		iv.) n is shorter than array length()\
		v.) valid test case\
	3.)bool locateSequence(const string a[], int n, string target, int& begin, int& end);\
		i.) negative n value()\
		ii.) valid test case()\
		iii.) all values are equal to target()\
		iv.) array starts with sequence()\
		v.) array ends with sequence()\
	4.) int locationOfMin(const string a[], int n);\
		i.) negative n value()\
		ii.) two min values()\
		iii.) no elements()\
	5.)int moveToEnd(string a[], int n, int pos);\
		i.) negative n value()\
		ii.) element already at end()\
		iii.) valid test case()\
		iv.) pos not in array()\
	6.) int moveToBeginning(string a[], int n, int pos);\
		i.) negative n value()\
		ii.) element already at beginning()\
		iii.) valid test case()\
		iv.)pos not in array()\
	7.)int locateDifference(const string a1[], int n1, const string a2[], int n2);\
		i.)negative n1 or n2 value()\
		ii.) arrays are the same()\
		iii.) arrays are different size but valid()\
		iv.) arrays are valid()\
	8.) int eliminateDups(string a[], int n);\
		i.)negative n value()\
		ii.)repeats at the beginning()\
		iii.) repeats at the end()\
		iv.) no repeats()\
		v.) valid test case()\
	9.) bool subsequence(const string a1[], int n1, const string a2[], int n2);\
		i.) n1 or n2 is negative()\
		ii.) arrays are the same()\
		iii.) smaller array is not in the other one()\
		iv.) valid test case()\
		v.) empty sequence()\
	10.) int makeMerger(const string a1[], int n1, const string a2[], int n2, \
\pard\pardeftab720
\cf0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0string result[], int max);\
		i.)more than max elements()\
		ii.) n1 or n2 is negative\
		iii.) a1 or a2 is not non decreasing order()\
		iv.) valid test case()\
	11.) int divide(string a[], int n, string divider);\
		i.) n is negative()\
		ii.) low value at beginning()\
		iii.) high value at end()\
		iv.) valid test case()\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \
}